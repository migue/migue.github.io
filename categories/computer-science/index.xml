<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Computer Science | Just my thouhgts</title>
    <link>https://migue.github.io/categories/computer-science/</link>
      <atom:link href="https://migue.github.io/categories/computer-science/index.xml" rel="self" type="application/rss+xml" />
    <description>Computer Science</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Tue, 14 Apr 2020 15:14:30 +0100</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>Computer Science</title>
      <link>https://migue.github.io/categories/computer-science/</link>
    </image>
    
    <item>
      <title>InfluxDB storage subsystem: an introduction</title>
      <link>https://migue.github.io/post/quick-tour-influx-storage/</link>
      <pubDate>Tue, 14 Apr 2020 15:14:30 +0100</pubDate>
      <guid>https://migue.github.io/post/quick-tour-influx-storage/</guid>
      <description>&lt;p&gt;Writing on the blog about some of the technical stuff I usually enjoy and/or work with is something that’s always in my plans but I never find the right time do it. Due to all this quarantine related stuff, both my sleeping habits and the kid’s are being somehow affected and, well, here I am, staring at a blank page trying to start writing about databases. And, well, since I don’t longer work for an international company I thought it would be a good idea to somehow practice my poor English skills.&lt;/p&gt;
&lt;p&gt;This time my plan is to write about InfluxDB, a columnar oriented time-series database written in Go, and provide a quick tour of some of the most important characteristics of their storage engine.&lt;/p&gt;
&lt;p&gt;I have been dealing with InfluxDB for a while and I have gone way deeper than I would like to quite a few times but &lt;strong&gt;I am by no means an expert&lt;/strong&gt;, so, please, if I say something that’s not completely accurate, forgive me, and please, correct me.&lt;/p&gt;
&lt;p&gt;I’ve dealt with both the OpenSource and the Enterprise versions but everything here is going to be based on the former (to the best of my knowledge the storage engine is the same in both alternatives). The details included later in the post are based on the 1.8.x and 1.7.x branches (I know the 2.0 introduces quite a lot changes but I won’t talk about them here).&lt;/p&gt;
&lt;h1 id=&#34;before-getting-started&#34;&gt;Before getting started&lt;/h1&gt;
&lt;p&gt;Influx has gone through different storage engines through its short lifetime: LevelDB, BoltDB (not sure if there’s anymore) and, and this is just an educated guess, any of them completely satisfied the requirements that the InfluxDB folks were looking for: large batch deletes, hot backups, high throughput or a good compression performance among many others. So, in order to solve the previous points (it’s not an exhaustive list), they decided to go on their own and write a new storage engine (it&amp;rsquo;s a brave bet).&lt;/p&gt;
&lt;p&gt;Everything I am going to write about here is focused on this storage engine and I have no experience with the Influx versions where the underlying storage engine was LevelDB or BoltDB.&lt;/p&gt;
&lt;h1 id=&#34;influxdb-concepts&#34;&gt;InfluxDB concepts&lt;/h1&gt;
&lt;p&gt;Before we go into the details of the storage engine let me introduce a few concepts I think all of us should know about.&lt;/p&gt;
&lt;p&gt;Everything starts with a database concept, similar to a traditional RDBMS, which acts as the container of many of the capabilities that Influx provides: user management, retention policies, continuous queries, … Everything related to a database is represented under a folder in the filesystem.&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;retention policy&lt;/strong&gt; describes how long the data is kept around and how many copies of this data are stored in the cluster (for the OpenSource version the replication setting has no effect).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Measurements&lt;/strong&gt; are the “data structure” used to model how the data is stored in Influx and the fields associated with it.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Fields&lt;/strong&gt; represent the actual data value. These are required and, something really important, they are not indexed.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tags&lt;/strong&gt; represents metadata associated with the aforementioned fields. They are optional, but they are very useful because they are indexed and allow you to perform group by and/or filter operations (you can filter on fields as well, but since they are not indexed, this is not a performant operation).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Series&lt;/strong&gt; are a logical grouping of data defined by a measurement, a set of tags and a field. To me, this is one of the most important concepts that need to be clear while working with InfluxDB, because many of the different concepts revolve around it.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Shards&lt;/strong&gt;  contains the actual encoded and compressed data. They are represented by a TSM file on disk (more on this later). Every shard contains a specific set of series so all the points falling on a given series will be stored in the same shard.&lt;/p&gt;
&lt;p&gt;In order to get your data points inserted into the database, Influx defines a text-based protocol named &lt;strong&gt;line protocol&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;An example of how a single data point looks like in the &lt;strong&gt;line protocol&lt;/strong&gt; and how it maps to the concepts described before is shown in the picture below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://migue.github.io/img/influx-line-protocol.png&#34; alt=&#34;Influx Line Protocol&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;influxdb-storage-engine&#34;&gt;InfluxDB storage engine&lt;/h1&gt;
&lt;p&gt;At the beginning of the post, I described some of the features that, per my understanding, the Influx folks were looking for when building their storage engine and how all these requirements led them to their current storage solution.&lt;/p&gt;
&lt;p&gt;Their storage solution is similar to an LSM Tree and, from a high-level perspective, it is composed by:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A write-ahead log&lt;/li&gt;
&lt;li&gt;A collection of &lt;strong&gt;TSM&lt;/strong&gt; (read-only) files where the actual time series data is stored (similar to the SSTables)&lt;/li&gt;
&lt;li&gt;TSI files that serve as the inverted index used to quickly access the information. Prior to this version of the index, the data was held into an in-memory data structure, making it difficult to support high-cardinality scenarios (millions of series).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Before we move forward, a short note about how I plan to organize the contents. The original idea was to put everything I wanted to write down into a single post but it would be probably a little bit dense so I have decided to split it into 3 different parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The current one with the introduction to Influx, the overview of the storage engine and a quick tour around the WAL component and its cache counterpart.&lt;/li&gt;
&lt;li&gt;The second one will cover the details about the TSM.&lt;/li&gt;
&lt;li&gt;The third one will cover details about the TSI.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For this post, let’s try to go a little bit deeper into the write ahead log (WAL) and its cache counterpart.&lt;/p&gt;
&lt;h2 id=&#34;write-ahead-log-wal&#34;&gt;Write ahead log (WAL)&lt;/h2&gt;
&lt;p&gt;The WAL is a write-optimized data structure that allows the writes to be durable and its main goal is to allow the writes to be appended as fast as possible so it is not easily queryable.&lt;/p&gt;
&lt;p&gt;When a new write comes into the system the new points are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Stored at an in-memory cache (more about this in the next section).&lt;/li&gt;
&lt;li&gt;Serialized, compressed using Snappy and written to the WAL.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If we take a look at the 
&lt;a href=&#34;https://github.com/influxdata/influxdb/blob/1.8/tsdb/engine/tsm1/engine.go#L1367&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;source code&lt;/a&gt;
 we can see where this actually happens:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// WritePoints writes metadata and point data into the engine.
// It returns an error if new points are added to an existing key.
func (e *Engine) WritePoints(points []models.Point) error {
    ….
    // first try to write to the cache
    if err := e.Cache.WriteMulti(values); err != nil {
        return err
    }
 
    if e.WALEnabled {
        if _, err := e.WAL.WriteMulti(values); err != nil {
            return err
        }
    }
    return seriesErr
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that we could disable the WAL and, in this case, writes will only exist in the cache and could be lost if a cache snapshot has not happened.&lt;/p&gt;
&lt;p&gt;The format used to describe every one of the entries appended to the WAL follows a type-length-value encoding scheme with a single byte representing the type of the entry being stored (write, delete or a range delete), a 4 byte uint32 representing the length of the compressed block, followed by the actual compressed data block.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://migue.github.io/img/wal-entry-encoding.png&#34; alt=&#34;Wal entry encoding&#34;&gt;&lt;/p&gt;
&lt;p&gt;Looking again at the 
&lt;a href=&#34;https://github.com/influxdata/influxdb/blob/1.8/tsdb/engine/tsm1/wal.go#L1062&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;source code&lt;/a&gt;
 here we can see how the actual writing is performed:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Write writes entryType and the buffer containing compressed entry data.
func (w *WALSegmentWriter) Write(entryType WalEntryType, compressed []byte) error {
    var buf [5]byte
    buf[0] = byte(entryType)
    binary.BigEndian.PutUint32(buf[1:5], uint32(len(compressed)))
 
    if _, err := w.bw.Write(buf[:]); err != nil {
        return err
    }
 
    if _, err := w.bw.Write(compressed); err != nil {
        return err
    }
 
    w.size += len(buf) + len(compressed)
 
    return nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cache&#34;&gt;Cache&lt;/h2&gt;
&lt;p&gt;The cache component is an in-memory data structure that holds a copy of all the points persisted in the WAL. As we’ve already mentioned in the previous section, when a new write comes into the system the new points are stored in this cache.&lt;/p&gt;
&lt;p&gt;The aforementioned points are indexed by the key which is formed by the measurement name, the tag set and the unique field key. If we go back to our previous example where we had a single write coming into the system:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;infrastructure_metrics,server=server-1,container=container-1 cpu_usage=82
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The key would be represented by something like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://migue.github.io/img/wal-cache-key.png&#34; alt=&#34;WAL Cache Key&#34;&gt;&lt;/p&gt;
&lt;p&gt;The points stored in the cache are not compressed and an upper bound can be set so we can prevent unexpected out of memory situations (if the upper bound limit is exceeded new writes coming into the system will be rejected) and prevent the database service to be unexpectedly restarted.&lt;/p&gt;
&lt;p&gt;When the number of elements in the cache reaches a certain lower bound (it’s configurable as well) a snapshot of the cache is triggered to a TSM file and the corresponding WAL segment files are removed.&lt;/p&gt;
&lt;p&gt;If we take a quick look to the 
&lt;a href=&#34;https://github.com/influxdata/influxdb/blob/1.8/tsdb/engine/tsm1/engine.go#L1968&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;source code&lt;/a&gt;
 we can see the behavior described in the previous paragraph:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// compactCache continually checks if the WAL cache should be written to disk.
func (e *Engine) compactCache() {
    t := time.NewTicker(time.Second)
    defer t.Stop()
    for {
        e.mu.RLock()
        quit := e.snapDone
        e.mu.RUnlock()
 
        select {
        case &amp;lt;-quit:
            return
 
        case &amp;lt;-t.C:
            e.Cache.UpdateAge()
            if e.ShouldCompactCache(time.Now()) {
                start := time.Now()
                e.traceLogger.Info(&amp;quot;Compacting cache&amp;quot;, zap.String(&amp;quot;path&amp;quot;, e.path))
                err := e.WriteSnapshot()
                if err != nil &amp;amp;&amp;amp; err != errCompactionsDisabled {
                    e.logger.Info(&amp;quot;Error writing snapshot&amp;quot;, zap.Error(err))
                    atomic.AddInt64(&amp;amp;e.stats.CacheCompactionErrors, 1)
                } else {
                    atomic.AddInt64(&amp;amp;e.stats.CacheCompactions, 1)
                }
                atomic.AddInt64(&amp;amp;e.stats.CacheCompactionDuration, time.Since(start).Nanoseconds())
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When a new read operation is received, the storage engine will merge data from the TSM files with the data stored in the cache (so you can read data that hasn’t been snapshotted into the TSM files yet). At query processing time, a copy of the data is done so any new write coming into the system won’t affect the results of any running query.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;This post has been a short intro to InfluxDB and a brief overview of its storage subsystem. In addition to the previous intros, we’ve covered a few details of the WAL + Cache storage subsystem elements. As I have already mentioned, my idea is to publish two more posts: one of them covering a few details of the TSM part and the other one going through the inner workings of the TSI component.&lt;/p&gt;
&lt;p&gt;Of course, I am aware this is just an introduction, and the devil is in the details, but I do hope this provides you some insights into a few database design concepts and how a concrete database applies them.&lt;/p&gt;
&lt;p&gt;Thanks for reading.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Books and Talks</title>
      <link>https://migue.github.io/post/books-and-talks/</link>
      <pubDate>Mon, 03 Feb 2020 15:14:30 +0100</pubDate>
      <guid>https://migue.github.io/post/books-and-talks/</guid>
      <description>&lt;p&gt;I would like to share with you a bunch of the tech talks I have recently watched or some of the latest books I have enjoyed.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disclaimer&lt;/strong&gt;: this list is just a set of resources I have gone through more or less &amp;ldquo;recently&amp;rdquo; about a few different topics I use to enjoy. It&amp;rsquo;s not my goal to create a &amp;ldquo;Best Talks/Papers/Whatever List&amp;rdquo;, just wanted to share with you all some of the things I have found interesting lately (all the resources are listed in no specific order).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disclaimer 2&lt;/strong&gt;: by &amp;ldquo;lately&amp;rdquo; I mean the last ~1.5 years, so probably many of the contents linked below will be quite old for most of you (I have slowed down a lot on my work-related stuff, but this is a different story).&lt;/p&gt;
&lt;p&gt;If you do like databases, systems engineering, cloud computing, runtimes and low-level programming, this list might contain some pointers to a book/talk you could enjoy.&lt;/p&gt;
&lt;h2 id=&#34;talks&#34;&gt;Talks&lt;/h2&gt;
&lt;h3 id=&#34;lets-talk-locks-by-kavya-joshi&#34;&gt;Let&amp;rsquo;s Talk Locks! by Kavya Joshi&lt;/h3&gt;
&lt;p&gt;An amazing talk about how locks are used at different places (Linux syscalls, Go programming language) and its performance implications.&lt;/p&gt;
&lt;p&gt;Actually, any talk coming from Kavya is usually wonderful.&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.infoq.com/presentations/go-locks/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Video&lt;/a&gt;
&lt;/p&gt;
&lt;h3 id=&#34;ebtree--design-for-a-scheduler-and-use-almost-everywhere-by-andjelko-iharos&#34;&gt;EBtree — Design for a Scheduler and Use (Almost) Everywhere by Andjelko Iharos&lt;/h3&gt;
&lt;p&gt;This talk goes into the evolution of HAProxy’s internals and how the created the EBTree data structure in order to manage active and suspended tasks within their scheduler (and how they ended up using it almost everywhere)&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.infoq.com/presentations/ebtree-design/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Video&lt;/a&gt;
&lt;/p&gt;
&lt;h3 id=&#34;performance-matters-by-emery-berger&#34;&gt;Performance Matters by Emery Berger&lt;/h3&gt;
&lt;p&gt;I simply love this talk. Emery goes through many of the different factors that, potentially, can affect performance on modern hardware: memory layout, instruction prefetching, branch prediction, &amp;hellip; and some surprising ones like env variables.&lt;/p&gt;
&lt;p&gt;During the talk, he presents the &lt;strong&gt;stabilizer&lt;/strong&gt; tool which randomizes programs layouts during runtime and introduced 
&lt;a href=&#34;https://www.usenix.org/node/196222&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;coz&lt;/a&gt;
, a causal profiler.&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=r-TLSBdHe1A&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Video&lt;/a&gt;
&lt;/p&gt;
&lt;h3 id=&#34;pid-loops-and-the-art-of-keeping-systems-stable-by-colm-maccárthaigh&#34;&gt;PID Loops and the Art of Keeping Systems Stable by Colm MacCárthaigh&lt;/h3&gt;
&lt;p&gt;I like Colm&amp;rsquo;s talks a lot. In this case, the talk goes through PID loops, control theory and how a bunch of AWS systems apply these design principles.&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.infoq.com/presentations/pid-loops/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Video&lt;/a&gt;
&lt;/p&gt;
&lt;h3 id=&#34;structured-concurrency-by-roman-elizarov&#34;&gt;Structured Concurrency by Roman Elizarov&lt;/h3&gt;
&lt;p&gt;Great talk about the evolution of asynchronous APIS in different programming languages and platforms and how they have applied the structured concurrency concepts to the design of the Kotlin&amp;rsquo;s concurrency libraries.&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=Mj5P47F6nJg&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Video&lt;/a&gt;
&lt;/p&gt;
&lt;h3 id=&#34;reduce-your-storage-costs-with-transient-replication-and-cheap-quorums-by-alex-petrov&#34;&gt;Reduce your storage costs with Transient Replication and Cheap Quorums by Alex Petrov&lt;/h3&gt;
&lt;p&gt;Alex talks about 
&lt;a href=&#34;http://www2.cs.uh.edu/~paris/MYPAPERS/Icdcs86.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Voting With Witnesses&lt;/a&gt;
 a replication schema which is used in Google Spanner and Megastore and has inspired Apache Cassandra&amp;rsquo;s Transient Replication and Cheap Quorums implementation&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=pEtRBid5oeA&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Video&lt;/a&gt;
&lt;/p&gt;
&lt;h3 id=&#34;ftrace-where-modifying-a-running-kernel-all-started-by-steven-rostedt&#34;&gt;ftrace: Where modifying a running kernel all started by Steven Rostedt&lt;/h3&gt;
&lt;p&gt;If you&amp;rsquo;ve ever wondered how tracing works in the Linux kernel you should probably watch it. A highly technical talk but really well executed even an stupid like myself could &lt;em&gt;understand&lt;/em&gt; it.&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=93uE_kWWQjs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Video&lt;/a&gt;
&lt;/p&gt;
&lt;h3 id=&#34;applicable-and-achievable-formal-verification-by-heidy-khlaaf&#34;&gt;Applicable and Achievable Formal Verification by Heidy Khlaaf&lt;/h3&gt;
&lt;p&gt;Heidy provides a nice overview of a few verification tools and techniques deployed in the safety critical industry and shows how this could be adapted to your systems.&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=GIYtzygBgA4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Video&lt;/a&gt;
&lt;/p&gt;
&lt;h3 id=&#34;correctness-proofs-of-distributed-systems-with-isabellehol-by--martin-kleppmann&#34;&gt;Correctness proofs of distributed systems with Isabelle/HOL by  Martin Kleppmann&lt;/h3&gt;
&lt;p&gt;An extended version of the talk that Martin did at 
&lt;a href=&#34;https://www.youtube.com/watch?v=7w4KC6i9Yac&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Strange Loop 2019&lt;/a&gt;
. He explores how Isabelle can be used to analyze algorithms used in distributed systems, and prove them correct.&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=Uav5jWHNghY&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Video&lt;/a&gt;
&lt;/p&gt;
&lt;h2 id=&#34;books&#34;&gt;Books&lt;/h2&gt;
&lt;h3 id=&#34;database-internals-by-alex-petrov&#34;&gt;Database internals by Alex Petrov&lt;/h3&gt;
&lt;p&gt;Alex has done an amazing job writing this book. You will find different topics: storage engines like BTrees and LSMs, how data is physically stored and the different building blocks involved, distributed systems and database clustering among many others&lt;/p&gt;
&lt;p&gt;If you like databases and its internals this book is going to be a fun read.&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;http://shop.oreilly.com/product/0636920174462.do&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;O&amp;rsquo;Reilly&lt;/a&gt;
&lt;/p&gt;
&lt;h3 id=&#34;serious-cryptography-by-jean-philippe-aumasson&#34;&gt;Serious Cryptography by Jean-Philippe Aumasson&lt;/h3&gt;
&lt;p&gt;Another wonderful book. A practical guide to modern encryption that goes through the fundamental mathematical concepts at the heart of cryptography: authenticated encryption, hash functions, block ciphers, and public-key techniques (RSA and elliptic curve cryptography).&lt;/p&gt;
&lt;p&gt;Totally recommended if you want to learn a little bit more about cryptography, and, even if you&amp;rsquo;re a seasoned practitioner (not my case) I think you can learn a few things.&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;http://shop.oreilly.com/product/9781593278267.do&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;O&amp;rsquo;Reilly&lt;/a&gt;
&lt;/p&gt;
&lt;h3 id=&#34;optimizing-java-by-benjamin-evans-james-gough-and-chris-newland&#34;&gt;Optimizing Java By Benjamin Evans, James Gough, and Chris Newland&lt;/h3&gt;
&lt;p&gt;One more book I have enjoyed a lot. A practical approach to JVM performance tuning and how to identify and solve performance related issues. The book will help you to understand Java platform&amp;rsquo;s internals (if you&amp;rsquo;re willing to go through it :) )&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;http://shop.oreilly.com/product/0636920042983.do&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;O&amp;rsquo;Reilly&lt;/a&gt;
&lt;/p&gt;
&lt;h3 id=&#34;efficient-io-with-io_uring&#34;&gt;Efficient IO with io_uring&lt;/h3&gt;
&lt;p&gt;I wasn&amp;rsquo;t sure where to put this resource; technically this is not a book, nor a paper either. Anyway, this is a gorgeous read about the newest Linux IO interface, io_uring and compare it to the current alternatives.&lt;/p&gt;
&lt;p&gt;Why this work is being done, how this works, &amp;hellip; IO_URING is a huge step forward in the Linux kernel and this short introduction provides a gentle introduction&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://kernel.dk/io_uring.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IO_URING introduction&lt;/a&gt;
&lt;/p&gt;
&lt;h3 id=&#34;cloud-native-data-center-networking-by-dinesh-dutt&#34;&gt;Cloud Native Data Center Networking By Dinesh Dutt&lt;/h3&gt;
&lt;p&gt;A really nice read about how modern cloud native data centers networks work and the steps required to design a datacenter that&amp;rsquo;s reliable and easy to manage. A mix of theory and practice which tries to guide the reader through everything which is needed to create and operate a network infrastructure in a modern datacenter.&lt;/p&gt;
&lt;p&gt;The book covers many different topics: network disaggregation, routing protocols, network virtualization, &amp;hellip;&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;http://shop.oreilly.com/product/0636920217930.do&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;O&amp;rsquo;Reilly&lt;/a&gt;
&lt;/p&gt;
&lt;h3 id=&#34;bpf-performance-tools-linux-system-and-application-observability-by-brendan-gregg&#34;&gt;BPF Performance Tools: Linux System and Application Observability by Brendan Gregg&lt;/h3&gt;
&lt;p&gt;I am still going through it, but I am enjoying it so much I thought I should include it in this list. A really comprehensive guide about BPF tools, performance engineering, and kernel internals. The book includes tons of examples,tools, &amp;hellip;&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.oreilly.com/library/view/bpf-performance-tools/9780136588870/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;O&amp;rsquo;Reilly&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;My original idea was to include a section with the papers I have recently enjoyed as well, but the post had become way too long that I decided to split it and do a follow-up including the academic papers.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
